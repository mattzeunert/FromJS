import {
  babelPlugin,
  LevelDBLogServer,
  HtmlToOperationLogMapping,
  LocStore,
  traverseDomOrigin
} from "@fromjs/core";
import { traverse } from "./src/traverse";
import StackFrameResolver, {
  ResolvedStackFrame
} from "./src/StackFrameResolver";
import * as fs from "fs";
import * as prettier from "prettier";
import * as Babel from "babel-core";
import * as crypto from "crypto";
import * as path from "path";
import * as express from "express";
import * as bodyParser from "body-parser";
import * as WebSocket from "ws";
import * as http from "http";
import { createProxy } from "./backend.createProxy";
import { BackendOptions } from "./BackendOptions";
import { template } from "lodash";
import * as ui from "@fromjs/ui";

import * as getFolderSize from "get-folder-size";
import * as responseTime from "response-time";

let uiDir = require
  .resolve("@fromjs/ui")
  .split(/[\/\\]/g)
  .slice(0, -1)
  .join("/");
let coreDir = require
  .resolve("@fromjs/core")
  .split(/[\/\\]/g)
  .slice(0, -1)
  .join("/");
let fromJSInternalDir = path.resolve(__dirname + "/../fromJSInternal");

let startPageDir = path.resolve(__dirname + "/../start-page");

function ensureDirectoriesExist(options: BackendOptions) {
  const directories = [
    options.sessionDirectory,
    options.getCertDirectory(),
    options.getTrackingDataDirectory()
  ];
  directories.forEach(dir => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
    }
  });
}
function createBackendCerts(options: BackendOptions) {
  fs.mkdirSync(options.getBackendServerCertDirPath());
  const Forge = require("node-forge");
  const pki = Forge.pki;
  var keys = pki.rsa.generateKeyPair({ bits: 2048, e: 0x10001 });

  var cert = pki.createCertificate();
  cert.publicKey = keys.publicKey;
  cert.validity.notBefore = new Date();
  cert.validity.notBefore.setDate(cert.validity.notBefore.getDate() - 1);
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(
    cert.validity.notBefore.getFullYear() + 10
  );
  cert.sign(keys.privateKey, Forge.md.sha256.create());

  fs.writeFileSync(
    options.getBackendServerCertPath(),
    pki.certificateToPem(cert)
  );
  fs.writeFileSync(
    options.getBackendServerPrivateKeyPath(),
    pki.privateKeyToPem(keys.privateKey)
  );
}

const LOG_PERF = true;
const DELETE_EXISTING_LOGS_AT_START = false;

export default class Backend {
  constructor(options: BackendOptions) {
    if (DELETE_EXISTING_LOGS_AT_START) {
      console.log(
        "deleting existing log data, this makes sure perf data is more comparable... presumably leveldb slows down with more data"
      );
      require("rimraf").sync(options.getLocStorePath());
      require("rimraf").sync(options.getTrackingDataDirectory());
    }
    ensureDirectoriesExist(options);

    getFolderSize(options.sessionDirectory, (err, size) => {
      console.log("Session size: ", (size / 1024 / 1024).toFixed(2) + " MB");
    });

    let sessionConfig;
    function saveSessionConfig() {
      fs.writeFileSync(
        options.getSessionJsonPath(),
        JSON.stringify(sessionConfig, null, 4)
      );
    }
    if (fs.existsSync(options.getSessionJsonPath())) {
      const json = fs.readFileSync(options.getSessionJsonPath()).toString();
      sessionConfig = JSON.parse(json);
    } else {
      sessionConfig = {
        accessToken: crypto.randomBytes(32).toString("hex")
      };
      saveSessionConfig();
    }

    var { bePort, proxyPort } = options;

    const app = express();

    if (LOG_PERF) {
      app.use(
        responseTime((req, res, time) => {
          console.log(req.method, req.url, time + "ms");
        })
      );
    }

    app.use(bodyParser.json({ limit: "250mb" }));

    if (!fs.existsSync(options.getBackendServerCertDirPath())) {
      createBackendCerts(options);
    }

    const http = require("http");
    const server = http.createServer(app);

    const wss = new WebSocket.Server({
      server
    });

    // Needed or else websocket connection doesn't work because of self-signed cert
    process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

    // "Access-Control-Allow-Origin: *" allows any website to send data to local server
    // but that might be bad, so limit access to code generated by Babel plugin
    app.verifyToken = function verifyToken(req) {
      const { authorization } = req.headers;
      const { accessToken } = sessionConfig;
      if (authorization !== accessToken) {
        throw Error(
          "Token invalid: " + authorization + " should be " + accessToken
        );
      }
    };

    function getProxy() {
      return proxyInterface;
    }

    setupUI(options, app, wss, getProxy);
    let { storeLocs } = setupBackend(options, app, wss, getProxy);

    let proxyInterface;
    const proxyReady = createProxy({
      accessToken: sessionConfig.accessToken,
      options,
      storeLocs
    });
    proxyReady.then(pInterface => {
      proxyInterface = pInterface;
      "justtotest" && getProxy();
      if (options.onReady) {
        options.onReady();
      }
    });

    ["/storeLogs", "/inspect", "/inspectDOM"].forEach(path => {
      // todo: don't allow requests from any site
      app.options(path, allowCrossOriginRequests);
    });

    const serverReady = new Promise(resolve => {
      server.listen(bePort, () => resolve());
    });

    Promise.all([proxyReady, serverReady]).then(function() {
      console.log("Server listening on port " + bePort);
    });
  }
}

function setupUI(options, app, wss, getProxy) {
  console.log("setupui");
  wss.on("connection", (ws: WebSocket) => {
    console.log("On ws connection");
    if (domToInspect) {
      ws.send(
        JSON.stringify({
          type: "inspectDOM",
          ...getDomToInspectMessage()
        })
      );
    }
  });

  app.get("/", (req, res) => {
    let html = fs.readFileSync(uiDir + "/index.html").toString();
    html = html.replace(/BACKEND_PORT_PLACEHOLDER/g, options.bePort.toString());
    getProxy()
      ._getEnableInstrumentation()
      .then(function(enabled) {
        html = html.replace(
          /BACKEND_PORT_PLACEHOLDER/g,
          options.bePort.toString()
        );
        html = html.replace(
          /ENABLE_INSTRUMENTATION_PLACEHOLDER/g,
          enabled.toString()
        );
        res.send(html);
      });
  });

  app.use(express.static(uiDir));
  app.use("/fromJSInternal", express.static(fromJSInternalDir));
  app.use("/start", express.static(startPageDir));

  function getDomToInspectMessage(charIndex?) {
    if (!domToInspect) {
      return {
        err: "Backend has no selected DOM to inspect"
      };
    }

    const mapping = new HtmlToOperationLogMapping((<any>domToInspect).parts);

    const html = mapping.getHtml();
    let goodDefaultCharIndex = 0;

    if (charIndex !== undefined) {
      goodDefaultCharIndex = charIndex;
    } else {
      const charIndexWhereTextFollows = html.search(/>[^<]/) + 1;
      if (
        charIndexWhereTextFollows !== -1 &&
        mapping.getOriginAtCharacterIndex(charIndexWhereTextFollows)
      ) {
        goodDefaultCharIndex = charIndexWhereTextFollows;
      }
    }

    return {
      html: (<any>domToInspect).parts.map(p => p[0]).join(""),
      charIndex: goodDefaultCharIndex
    };
  }

  let domToInspect = null;
  app.post("/inspectDOM", (req, res) => {
    app.verifyToken(req);

    res.set("Access-Control-Allow-Origin", "*");
    res.set(
      "Access-Control-Allow-Headers",
      "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"
    );

    domToInspect = req.body;

    broadcast(
      wss,
      JSON.stringify({
        type: "inspectDOM",
        ...getDomToInspectMessage(req.body.charIndex)
      })
    );

    res.end("{}");
  });

  let logToInspect = null;
  app.post("/inspectDomChar", (req, res) => {
    if (!domToInspect) {
      res.status(500);
      res.json({
        err: "Backend has no selected DOM to inspect"
      });
      res.end();
      return;
    }

    const mapping = new HtmlToOperationLogMapping((<any>domToInspect).parts);
    const mappingResult: any = mapping.getOriginAtCharacterIndex(
      req.body.charIndex
    );

    if (!mappingResult.origin) {
      res.end(
        JSON.stringify({
          logId: null
        })
      );
      return;
    }

    const origin = mappingResult.origin;

    res.end(
      JSON.stringify({
        logId: origin.trackingValue,
        charIndex: traverseDomOrigin(origin, mappingResult.charIndex)
      })
    );
  });
  app.post("/inspect", (req, res) => {
    allowCrossOrigin(res);

    app.verifyToken(req);
    logToInspect = req.body.logId;
    res.end("{}");

    broadcast(
      wss,
      JSON.stringify({
        type: "inspectOperationLog",
        operationLogId: logToInspect
      })
    );
  });
}

function setupBackend(options: BackendOptions, app, wss, getProxy) {
  const locStore = new LocStore(options.getLocStorePath());
  const logServer = new LevelDBLogServer(
    options.getTrackingDataDirectory(),
    locStore
  );

  app.get("/jsFiles/compileInBrowser.js", (req, res) => {
    const code = fs
      .readFileSync(coreDir + "/../compileInBrowser.js")
      .toString();
    res.end(code);
  });
  app.get("/jsFiles/babel-standalone.js", (req, res) => {
    const code = fs
      .readFileSync(coreDir + "/../babel-standalone.js")
      .toString();
    res.end(code);
  });

  app.post("/setEnableInstrumentation", (req, res) => {
    const { enableInstrumentation } = req.body;
    getProxy().setEnableInstrumentation(enableInstrumentation);

    res.end(JSON.stringify(req.body));
  });

  app.post("/storeLogs", (req, res) => {
    app.verifyToken(req);

    res.set("Access-Control-Allow-Origin", "*");
    res.set(
      "Access-Control-Allow-Headers",
      "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"
    );

    const startTime = new Date();
    logServer.storeLogs(req.body.logs, function() {
      const timePassed = new Date().valueOf() - startTime.valueOf();
      const timePer1000 =
        Math.round((timePassed / req.body.logs.length) * 1000 * 10) / 10;
      if (LOG_PERF) {
        console.log(
          "storing logs took " +
            timePassed +
            "ms, per 1000 logs: " +
            timePer1000 +
            "ms"
        );
      }
    });

    req.body.evalScripts.forEach(function(evalScript) {
      getProxy().registerEvalScript(evalScript);
    });

    // fs.writeFileSync("logs.json", JSON.stringify(logServer._storedLogs));
    // console.log("stored logs", req.body.logs.length);

    res.end(JSON.stringify({ ok: true }));
  });

  app.post("/loadLog", (req, res) => {
    // crude way to first wait for any new logs to be sent through...
    setTimeout(function() {
      // console.log(Object.keys(internalServerInterface._storedLogs));
      console.log(req.body);
      logServer.loadLog(req.body.id, function(err, log) {
        res.end(JSON.stringify(log));
      });
    }, 500);
  });

  app.post("/traverse", (req, res) => {
    const { logId, charIndex } = req.body;
    const tryTraverse = (previousAttempts = 0) => {
      logServer.hasLog(logId, hasLog => {
        if (hasLog) {
          finishRequest();
        } else {
          const timeout = 250;
          const timeElapsed = timeout * previousAttempts;
          if (timeElapsed > 5000) {
            res.status(500);
            res.end(
              JSON.stringify({
                err: "Log not found (" + logId + ")- might still be saving data"
              })
            );
          } else {
            setTimeout(() => {
              tryTraverse(previousAttempts + 1);
            }, timeout);
          }
        }
      });
    };

    const finishRequest = async function finishRequest() {
      let steps;
      try {
        if (LOG_PERF) {
          console.time("Traverse " + logId);
        }
        steps = await traverse(
          {
            operationLog: logId,
            charIndex: charIndex
          },
          [],
          logServer
        );
        if (LOG_PERF) {
          console.timeEnd("Traverse " + logId);
        }
      } catch (err) {
        res.status(500);
        res.end(
          JSON.stringify({
            err: "Log not found in backend (" + logId + ")"
          })
        );
      }

      res.end(JSON.stringify({ steps }));
    };

    tryTraverse();
  });

  const resolver = new StackFrameResolver({ proxyPort: options.proxyPort });

  app.get("/resolveStackFrame/:loc", (req, res) => {
    locStore.getLoc(req.params.loc, loc => {
      resolver.resolveFrameFromLoc(loc).then(rr => {
        res.end(JSON.stringify(rr, null, 4));
      });
    });
  });

  app.get("/viewFullCode/:url", (req, res) => {
    const url = decodeURIComponent(req.params.url);
    res.end(resolver.getFullSourceCode(url));
  });

  app.post("/prettify", (req, res) => {
    res.end(
      JSON.stringify({
        code: prettier.format(req.body.code, { parser: "babylon" })
      })
    );
  });

  app.post("/instrument", (req, res) => {
    const code = req.body.code;

    getProxy()
      .instrumentForEval(code)
      .then(babelResult => {
        res.end(
          JSON.stringify({ instrumentedCode: babelResult.instrumentedCode })
        );
      });
  });

  return {
    storeLocs: locs => {
      locStore.write(locs, function() {});
    }
  };
}

function broadcast(wss, data) {
  wss.clients.forEach(function each(client) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  });
}

function allowCrossOriginRequests(req, res) {
  allowCrossOrigin(res);
  res.end();
}

function allowCrossOrigin(res) {
  res.set("Access-Control-Allow-Origin", "*");
  res.set(
    "Access-Control-Allow-Headers",
    "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"
  );
}

export { BackendOptions };
